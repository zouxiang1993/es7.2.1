## 简介
每一个索引都被分割成多个分片，每个分片都可以有很多副本。
这些副本被称为一个副本组，在增删文档时，副本组必须保持同步。
使分片的副本保持同步并从中读取内容的过程就是"数据复制模型"。

ES的数据复制模型基于主-备模型，在微软的PacificA论文中有很好的描述。
该模型将副本组中的一个副本作为"主分片"，其他副本称为"副本分片"。
主分片是所有写操作的入口，它负责验证并确保写操作是正确的。
一旦主分片接收了一个写操作，主分片还负责将这个操作复制到其他分片。

下面从总体上概述ES的数据复制模型，并讨论它对读写操作之间各种交互的影响。 

## 基本写模型
每一个写操作首先通过路由解析到一个副本组，通常是通过文档ID来路由。
一旦确定了副本组，这个操作会在内部转发到这个副本组内当前的主分片上。
主分片负责验证操作的正确性，并转发给其他副本。由于副本可能会下线，主分片不需要复制给所有副本。
相反，ES会维护一个副本列表，只有该列表内的副本必须接收写操作。该列表称为"同步副本(in-sync copies)"，由master节点维护。
顾名思义，这些是保证已经处理了所有 已经给用户返回确认消息 的写操作的"良好"副本的集合。
主分片负责维护此不变性，因此必须将所有写操作复制到这个集合中的每个副本。

主分片遵循以下基本流程:  
1. 验证写操作，如果其结构上非法，则将其拒绝(例如: 在object字段上传入数字)
2. 在本地执行操作。这也会验证字段的内容，如果非法，则将其拒绝(例如: 关键字长度在lucene中太长)
3. 将操作转发到当前同步副本集中的每个副本。如果有多个副本，则是并行进行的。
4. 一旦同步副本集中的所有副本都成功执行了操作并相应了主分片，主分片会向客户端确认请求的成功完成。

## 故障处理 
在写索引期间，很多情况都可能导致出错: 磁盘可能会损坏，节点之间可能会断开连接，
或者某些配置错误导致副本上的操作失败，尽管这个操作在主分片上执行成功了。
这些情况很少见，但主分片必须有应对措施。 

如果主分片发生故障，主分片所在的节点将向master汇报这个信息。写操作会等待(默认1分钟)master将另外一个副本提升为新的主分片。
然后，这个写操作会转发到新的主分片上进行处理。
master节点还会监控其他节点的健康状况，并可能主动的降级一个主分片。
当持有主分片的节点由于网络问题而与集群隔离时，会发生这种情况。  

一旦写操作在主分片上成功执行，主分片就必须处理在其他副本上执行失败的潜在问题。
这可能是由于副本的实际故障或由于网络问题导致操作无法到达副本(或阻止副本进行响应)引起的。
所有这些都具有相同的最终结果: 同步副本集 中的某个分片丢失了一个操作。 
为了避免违反不变式, 主分片向master节点发送一条消息，请求从同步副本集中删除有问题的副本。
只有在master确认已经删除该副本后，主分片才向客户端确认该操作。 
master节点还会指示另一个节点开始构建新的分片副本，以将系统恢复到正常状态。 

在主分片转发操作到其他副本时，主分片还使用其他副本来验证它是否还是当前的主分片。
如果一个主分片由于网络分区或者较长的GC而被隔离，它可能会继续处理接收到的写操作，
然后才意识到它已经被降级。来自过期的主分片的写操作将被副本分片拒绝。 
如果主分片收到来自副本分片的拒绝响应，它将与master节点联系并得知它已经被降级。
然后写操作会被路由到新的主分片。

### 如果没有副本分片会发生什么? 
这是一个可能出现的场景，可能是索引settings配置的没有副本，也可能是所有的副本都已经失败。
这时，主分片在没有任何外部验证的情况下执行操作，这看上去是有问题的。 
另一方面，主分片不能单独的使其他副本分片失效，但它可以请求master节点来做。
这意味着master节点知道主分片是唯一一个良好的副本。
因此，我们保证master节点不会将任何其他副本提升为主分片，并且索引到该主分片的所有操作都不会丢失。 
当然，由于此时只有1个副本运行，因此物理硬件问题可能会导致数据丢失。 

## 基本读模型
ES中的读操作，可以是轻量级的根据ID查找，也可以是重量级的查询和复杂的聚合(需要占用很多CPU资源)。
主-备模型的优点之一是，它使所有分片副本保持相同(正在执行中的操作除外)。
因此，单个同步副本(in-sync copy)足以满足读需求。 

当一个节点接收到读请求，该节点负责将其转发到持有相关分片的节点，整理合并结果并响应客户端。
我们将该节点称为该请求的协调节点。基本流程如下:  
1. 解析读请求相关的分片。由于大多数搜索将发送到一个甚至多个索引，
他们通常需要从多个分片中读取，每个分片代表数据的一个子集。  
2. 从每个分片副本组中选择一个分片，可以是主分片，也可以是副本分片。
默认情况下，ES会在所有分片中进行轮询。 
3. 向选中的分片发送shard级别的读请求。 
4. 合并响应结果。

### 分片失败 
当一个分片响应读请求失败时，协调节点会将请求发送到同一副本组中的另一个副本分片。
重复的失败可能会导致没有可用的副本分片。为了确保快速响应，如果一个或多个分片失败，以下APi将以部分结果响应: 
- Search 
- Multi Search
- Bulk 
- Multi Get 

只包含部分结果的响应仍返回 200 的HTTP状态码。分片故障由响应头中的 timed_out和_shards字段指示。

### 一些简单的启示: 
#### 高效读
在正常情况下一个读操作只会在一个副本组中执行一次。
只有在失败的情况下，才可能在另外的分片上执行多次。 

#### 未确认读
因为主分片首先在本地执行写操作，然后将写操作同步到其他分片，再向客户端确认。 
因此可能有一个并发的读操作读到了还没有向客户端确认的修改。 

#### 默认2个拷贝(一个主分片，一个副本分片)
这个模型可以在只有2个副本的情况下有容错能力。而qrorum-based系统至少要3个才能容错。

### 故障
#### 单个分片可能影响 读/写 速度
由于在写索引时，主分片会等待同步副本集中的所有副本，因此一个慢副本会影响整个副本组。
这是我们为实现上面提到的"高效读"所付出的代价。当然，一个慢副本也会影响到路由到这个副本上的查询。

#### 脏读
一个隔离的主分片可能会暴露 没有向客户端确认 的写入。 这是由以下事实造成的: 
隔离的主分片在将请求发送到其他副本时或它与master节点通信时才意识到它是隔离的，
而此时，写操作已经被索引到主分片中，并且可以被并发的读操作来读取。
ES每秒钟(默认)ping一次master节点，并在不知道master节点时拒绝写操作，通过这种方式来减少这种风险。  